What happens when you initialize a repository? Why do you need to do it?
Initializing a git repository by running git init command creates a .git repository inside the current directory. You need this repository in order to save commits. git status displays the status of current repositories. This is especially helpful when no commits have been made and git log throws an error. git status will show that there is no commit history and all untracked files. 

How is the staging area different from the working directory and the repository? What value do you think it offers?
Staging area is basically a holding area for files which will be committed to the repository next time a git commit is run. This allows you to hold files from the working directory in a distinct "area" apart from files which will not be committed, without having to physically create a new directory in order to separate them.

How can you use the staging area to make sure you have one commit per logical change?
you can run git diff with no arguements to view the differences between working directory and staging area. This can help you ensure that you will only commit changes to a file or files which are logically related, and not any other chanages which may be in the working directory. Additionally, you can run git diff --staged to compare the staged changes with the previous commit in order to determine whether you will be committing too many logically disparate changes as compared to the previous commit.

What are some situations when branches would be helpful in keeping your history organized? How would branches help?
Branches can help keep history organized if experimental changes are to applied, or if changes with unknown results are made. This allows you to view how the chnages affect the project without the potential to break the project, and can be merged later. Additionally, if you want to add separate modes like a game "easy mode" or another language display, branches make this much easier and keep the project nicely organized. 

How do the diagrams help you visualize the branch structure?
Diagrams are a good way to describe the branch structure in a linear fashion with structural branches which helps to visualize when and where branches occur, and why some commits may not be visible due to the branch structure. If a change is applied and committed to a branch while not working at the current HEAD, it may be impossible to see this commit later via git log. For this reason diagrams assist with visualizing how master branches split and where to make and commit changes. 

What is the result of merging two branches together? Why do we represent it in the diagram the way we do?
Merging two branches consolidates the commit history of both branches in the git log. Functionally, this moves the most recent commit of each branch to the head of the merged branch. It can also have the unintended consequence of causing some commits to be unreachable if you don't know the commit id, so it's important to make commits to the head of a branch for this reason. This keeps the commit history linear and allows the branch merge to be represented properly on a diagram by merging the heads of each branch to create one single branch. 